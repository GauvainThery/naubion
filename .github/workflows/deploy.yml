name: Deploy to Production

on:
  workflow_run:
    workflows: ['Build and Publish Docker Images']
    types:
      - completed
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

env:
  REGISTRY: ghcr.io
  BACKEND_IMAGE_NAME: gauvainthery/naubion-backend
  FRONTEND_IMAGE_NAME: gauvainthery/naubion-frontend

jobs:
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    environment:
      name: ${{ github.event.inputs.environment || 'production' }}
      url: ${{ vars.APP_URL }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ vars.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Create environment file on server
        run: |
          ssh ${{ vars.SERVER_USER }}@${{ vars.SERVER_HOST }} "
            mkdir -p /opt/naubion
            cat > /opt/naubion/.env << 'EOF'
            # Generated by GitHub Actions on $(date)
            
            # Core Application Settings
            NODE_ENV=production
            LOG_LEVEL=${{ vars.LOG_LEVEL || 'warn' }}
            BACKEND_PORT=${{ vars.BACKEND_PORT || '8080' }}
            FRONTEND_PORT=${{ vars.FRONTEND_PORT || '3000' }}
            
            # CORS Configuration
            CORS_ORIGIN=${{ vars.CORS_ORIGIN }}
            
            # Database Configuration
            DB_HOST=${{ vars.DB_HOST }}
            DB_PORT=${{ vars.DB_PORT || '5432' }}
            DB_USERNAME=${{ vars.DB_USERNAME }}
            DB_PASSWORD=${{ secrets.DB_PASSWORD }}
            DB_DATABASE=${{ vars.DB_DATABASE }}
            
            # Cache Configuration
            CACHE_ANALYSIS_RESULTS=${{ vars.CACHE_ANALYSIS_RESULTS || 'true' }}
            CACHE_TTL_HOURS=${{ vars.CACHE_TTL_HOURS || '240' }}
            
            # Puppeteer Configuration
            PUPPETEER_EXECUTABLE_PATH=${{ vars.PUPPETEER_EXECUTABLE_PATH || '/usr/bin/chromium-browser' }}
            BROWSER_TIMEOUT=${{ vars.BROWSER_TIMEOUT || '120000' }}
            
            # Analysis Configuration
            MAX_CONCURRENT_ANALYSIS=${{ vars.MAX_CONCURRENT_ANALYSIS || '10' }}
            ANALYSIS_TIMEOUT=${{ vars.ANALYSIS_TIMEOUT || '300000' }}
            ANALYSIS_RETRIES=${{ vars.ANALYSIS_RETRIES || '3' }}
            
            # External Services
            MAILJET_API_KEY=${{ secrets.MAILJET_API_KEY }}
            MAILJET_API_SECRET=${{ secrets.MAILJET_API_SECRET }}
            MAILJET_CONTACT_LIST_ID=${{ vars.MAILJET_CONTACT_LIST_ID }}
            
            # Admin Configuration
            ADMIN_PASSWORD=${{ secrets.ADMIN_PASSWORD }}
            
            # Frontend Build Variables
            VITE_API_URL=${{ vars.VITE_API_URL }}
            VITE_APP_NAME=${{ vars.VITE_APP_NAME || 'Naubion' }}
            VITE_ENABLE_ANALYTICS=${{ vars.VITE_ENABLE_ANALYTICS || 'true' }}
          EOF
          "

      - name: Deploy Docker Compose
        run: |
          # Copy docker-compose.yml to server
          scp docker-compose.yml ${{ vars.SERVER_USER }}@${{ vars.SERVER_HOST }}:/opt/naubion/

          # Deploy application
          ssh ${{ vars.SERVER_USER }}@${{ vars.SERVER_HOST }} "
            cd /opt/naubion
            
            # Login to GitHub Container Registry
            echo '${{ secrets.GITHUB_TOKEN }}' | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin
            
            # Pull latest images
            docker compose pull
            
            # Deploy with zero downtime
            docker compose up -d --remove-orphans
            
            # Wait for health checks
            echo 'Waiting for services to be healthy...'
            sleep 30
            
            # Verify deployment
            if docker compose ps | grep -q 'Up.*healthy'; then
              echo 'Deployment successful!'
              docker compose ps
            else
              echo 'Deployment failed!'
              docker compose logs
              exit 1
            fi
            
            # Cleanup old images
            docker image prune -f
          "

      - name: Verify deployment
        run: |
          # Check if the application is responding
          sleep 10
          curl -f ${{ vars.APP_URL }}/api/health || exit 1
          echo "Application is healthy and responding!"

      - name: Notify deployment status
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
